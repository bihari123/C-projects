#define _WIN32_WINNT 0x0600 // For Windows Vista and later
#include <windows.h>
#include <psapi.h>
#include "./tlsh/include/tlsh.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <unordered_map>
#include <thread>
#include <chrono>
#include <TlHelp32.h>
#include "json.hpp"

using json = nlohmann::json;

class SecurityModule {
private:
    std::unordered_map<std::string, std::string> malwareSignatures;
    std::vector<std::string> personalDataPaths;

    void loadSignaturesFromFile(const std::string& filename) {
        std::ifstream file(filename);
        if (!file.is_open()) {
            std::cerr << "Failed to open file: " << filename << std::endl;
            return;
        }
        json jsonData;
        try {
            file >> jsonData;
        }
        catch (json::parse_error& e) {
            std::cerr << "JSON parsing error: " << e.what() << std::endl;
            return;
        }

        for (const auto& entry : jsonData) {
            if (entry.contains("tlsh") && entry.contains("name")) {
                malwareSignatures[entry["tlsh"]] = entry["name"];
            }
        }
    }

    std::string calculateTLSHHash(const std::string& filePath) {
        std::ifstream file(filePath, std::ios::binary);
        if (!file) {
            return "";
        }

        Tlsh tlsh;
        const int bufSize = 1024;
        char buffer[bufSize];
        while (file) {
            file.read(buffer, bufSize);
            tlsh.update((const unsigned char*)buffer, file.gcount());
        }
        tlsh.final();
        return tlsh.getHash();
    }

    bool checkMalwareSignature(const std::string& processName) {
        std::string processPath = getFullProcessPath(processName);
        if (processPath.empty()) {
            return false;
        }

        std::string tlshHash = calculateTLSHHash(processPath);
        if (tlshHash.empty()) {
            return false;
        }

        for (const auto& [signature, name] : malwareSignatures) {
            int difference = tlsh.diff(tlshHash.c_str(), signature.c_str());
            if (difference < 100) {  // Adjust this threshold as needed
                std::cout << "Potential malware detected: " << processName
                    << " (Matched: " << name << ")" << std::endl;
                return true;
            }
        }

        return false;
    }

    bool isAccessingPersonalData(HANDLE hProcess) {
        // This is a placeholder. Implement your logic here.
        // You might want to use Windows APIs to check file handles or monitor file system activity.
        return false;
    }

    std::string getFullProcessPath(const std::string& processName) {
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot == INVALID_HANDLE_VALUE) {
            return "";
        }

        PROCESSENTRY32 pe32;
        pe32.dwSize = sizeof(PROCESSENTRY32);

        if (!Process32First(hSnapshot, &pe32)) {
            CloseHandle(hSnapshot);
            return "";
        }

        do {
            if (processName == pe32.szExeFile) {
                HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pe32.th32ProcessID);
                if (hProcess != NULL) {
                    char path[MAX_PATH];
                    if (GetModuleFileNameEx(hProcess, NULL, path, MAX_PATH) != 0) {
                        CloseHandle(hProcess);
                        CloseHandle(hSnapshot);
                        return std::string(path);
                    }
                    CloseHandle(hProcess);
                }
            }
        } while (Process32Next(hSnapshot, &pe32));

        CloseHandle(hSnapshot);
        return "";
    }

public:
    SecurityModule() {
        loadSignaturesFromFile("path/to/your/threat_database.json");
        personalDataPaths = {
            "C:\\Users\\YourUsername\\Documents\\Personal",
            "C:\\Users\\YourUsername\\Pictures"
            // Add more paths as needed
        };
    }

    void monitorSystem() {
        DWORD aProcesses[1024], cbNeeded, cProcesses;
        if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
            return;
        }

        cProcesses = cbNeeded / sizeof(DWORD);

        for (unsigned int i = 0; i < cProcesses; i++) {
            if (aProcesses[i] != 0) {
                HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i]);
                if (hProcess != NULL) {
                    CHAR szProcessName[MAX_PATH] = "<unknown>";
                    HMODULE hMod;
                    DWORD cbNeeded;

                    if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
                        GetModuleBaseNameA(hProcess, hMod, szProcessName, sizeof(szProcessName) / sizeof(CHAR));
                    }

                    if (checkMalwareSignature(szProcessName)) {
                        std::cout << "Potential malware detected: " << szProcessName << std::endl;
                    }

                    if (isAccessingPersonalData(hProcess)) {
                        std::cout << "Process accessing personal data: " << szProcessName << std::endl;
                    }

                    CloseHandle(hProcess);
                }
            }
        }
    }
};

int main() {
    try {
        SecurityModule securityModule;
        while (true) {
            securityModule.monitorSystem();
            std::this_thread::sleep_for(std::chrono::seconds(5)); // Check every 5 seconds
        }
    }
    catch (const std::exception& e) {
        std::cerr << "An error occurred: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}